//go:generate mockgen -package notify -destination notifier_mock.go -source notifier.go Notifier
package notify

import (
	"context"
	"fmt"

	"github.com/pkg/errors"
	"golang.org/x/sync/errgroup"
)

var (
	ErrNotifyNotification                = errors.New("Notify notification")
	_                     Notifier       = NotifierFunc(nil)
	_                     StringNotifier = StringNotifierFunc(nil)
	emptyNotifier         Notifier       = NotifierFunc(nil)
)

type (
	// Notifier is used for Notify message in interface{} type.
	Notifier interface {
		// Notify sends and a message to the internal Notifier.
		// If WithTemplate option then the message is generated by execute data with template,
		// otherwise, the message is converted by fmt.Sprintf("%s", data)
		Notify(context.Context, interface{}) error
	}

	NotifierFunc func(context.Context, interface{}) error

	// Notifier is used for Notify message in string type.
	StringNotifier interface {
		// Notify sends and a message to the internal Notifier.
		Notify(context.Context, string) error
	}

	StringNotifierFunc func(context.Context, string) error

	defaultNotify struct {
		notifiers []Notifier
	}
)

func New(notifiers ...Notifier) Notifier {
	return &defaultNotify{notifiers: notifiers}
}

func NewWithStringNotifiers(stringNotifiers ...StringNotifier) Notifier {
	notifiers := make([]Notifier, len(stringNotifiers))
	for i := range stringNotifiers {
		notifiers[i] = stringNotifierToNotifier(stringNotifiers[i])
	}
	return combineNotifiers(notifiers...)
}

func (n *defaultNotify) Notify(ctx context.Context, data interface{}) error {
	var eg errgroup.Group

	for _, notifier := range n.notifiers {
		notifier := notifier
		eg.Go(func() error {
			return notifier.Notify(ctx, data)
		})
	}

	if err := eg.Wait(); err != nil {
		return errors.Wrap(ErrNotifyNotification, err.Error())
	}

	return nil
}

func (f NotifierFunc) Notify(ctx context.Context, data interface{}) error {
	if f == nil {
		return nil
	}
	return f(ctx, data)
}

func (f StringNotifierFunc) Notify(ctx context.Context, message string) error {
	if f == nil {
		return nil
	}
	return f(ctx, message)
}

func (f StringNotifierFunc) Notifier() Notifier {
	return stringNotifierToNotifier(f)
}

func stringNotifierToNotifier(stringNotifier StringNotifier) Notifier {
	return NotifierFunc(func(ctx context.Context, data interface{}) error {
		return stringNotifier.Notify(ctx, convertDataMessage(data))
	})
}

func convertDataMessage(data interface{}) string {
	var message string
	switch v := data.(type) {
	case string:
		message = v
	case []byte:
		message = string(v)
	default:
		message = fmt.Sprintf("%v", data)
	}
	return message
}

func combineNotifiers(notifiers ...Notifier) Notifier {
	switch len(notifiers) {
	case 0:
		return emptyNotifier
	case 1:
		return notifiers[0]
	default:
		return New(notifiers...)
	}
}
